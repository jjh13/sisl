<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Shift Invariant Space Library (SISL): sisl::array_n&lt; T, N, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shift Invariant Space Library (SISL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesisl.html">sisl</a></li><li class="navelem"><a class="el" href="classsisl_1_1array__n.html">array_n</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsisl_1_1array__n-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sisl::array_n&lt; T, N, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An n-dimensional array. This class abstracts away the concept of an n-dimensional array, it should be easy to create an array of type T on N dimensions. This is useful as it often ends up being the case that many integer sampling lattices can be broken down into interleaved Cartesian grids. At the end of the day, this implementation flattens the representation down onto dense linear memory.  
 <a href="classsisl_1_1array__n.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_8hpp_source.html">array.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sisl::array_n&lt; T, N, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsisl_1_1array__n__inherit__graph.png" border="0" usemap="#sisl_1_1array__n_3_01T_00_01N_00_01Allocator_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="sisl_1_1array__n_3_01T_00_01N_00_01Allocator_01_4_inherit__map" id="sisl_1_1array__n_3_01T_00_01N_00_01Allocator_01_4_inherit__map">
<area shape="rect" id="node3" href="classsisl_1_1sparse__array__n.html" title="An n&#45;dimensional sparese array. This class abstracts away the concept of an n&#45;dimensional array..." alt="" coords="5,165,147,204"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sisl::array_n&lt; T, N, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsisl_1_1array__n__coll__graph.png" border="0" usemap="#sisl_1_1array__n_3_01T_00_01N_00_01Allocator_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acb884565621b3575ce99935d0e8bd222"><td class="memItemLeft" align="right" valign="top"><a id="acb884565621b3575ce99935d0e8bd222"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:acb884565621b3575ce99935d0e8bd222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7093571759e20b2293748a5a72538980"><td class="memItemLeft" align="right" valign="top"><a id="a7093571759e20b2293748a5a72538980"></a>
typedef Allocator::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a7093571759e20b2293748a5a72538980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b77cbc107044e4797bbbdd31ff01be"><td class="memItemLeft" align="right" valign="top"><a id="a07b77cbc107044e4797bbbdd31ff01be"></a>
typedef Allocator::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a07b77cbc107044e4797bbbdd31ff01be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa34e632e035525184024e41e6059c2"><td class="memItemLeft" align="right" valign="top"><a id="adfa34e632e035525184024e41e6059c2"></a>
typedef Allocator::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:adfa34e632e035525184024e41e6059c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6b217f55e5f1f09382b1af6856a4b4"><td class="memItemLeft" align="right" valign="top"><a id="a5c6b217f55e5f1f09382b1af6856a4b4"></a>
typedef Allocator::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a5c6b217f55e5f1f09382b1af6856a4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de073fb52c6a7ef3d98301edc0c2922"><td class="memItemLeft" align="right" valign="top"><a id="a3de073fb52c6a7ef3d98301edc0c2922"></a>
typedef Allocator::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a3de073fb52c6a7ef3d98301edc0c2922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539a2aa750b350a3e8eaeb8a267d8694"><td class="memItemLeft" align="right" valign="top"><a id="a539a2aa750b350a3e8eaeb8a267d8694"></a>
typedef Allocator::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a539a2aa750b350a3e8eaeb8a267d8694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae665043637f423c1ef474515a129e0b7"><td class="memItemLeft" align="right" valign="top"><a id="ae665043637f423c1ef474515a129e0b7"></a>
typedef Allocator&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:ae665043637f423c1ef474515a129e0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5016fdf6f7a7e6eea1b519b938c3e8c6"><td class="memItemLeft" align="right" valign="top"><a id="a5016fdf6f7a7e6eea1b519b938c3e8c6"></a>
allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:a5016fdf6f7a7e6eea1b519b938c3e8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5287e20ac20856d3ce1af561d3d02a"><td class="memItemLeft" align="right" valign="top"><a id="acf5287e20ac20856d3ce1af561d3d02a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#acf5287e20ac20856d3ce1af561d3d02a">array_n</a> (const Allocator &amp;a=Allocator())</td></tr>
<tr class="memdesc:acf5287e20ac20856d3ce1af561d3d02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Default constructor, allocates nothing. <br /></td></tr>
<tr class="separator:acf5287e20ac20856d3ce1af561d3d02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37d133a8c067cdaf8063ba49205fdea"><td class="memItemLeft" align="right" valign="top"><a id="ab37d133a8c067cdaf8063ba49205fdea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#ab37d133a8c067cdaf8063ba49205fdea">array_n</a> (const Allocator &amp;a, unsigned int d0,...)</td></tr>
<tr class="memdesc:ab37d133a8c067cdaf8063ba49205fdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dim constructor. Allocates an array with N dimensions with maximum dimensions given by the parameters. <br /></td></tr>
<tr class="separator:ab37d133a8c067cdaf8063ba49205fdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014fd246834441f65441e88d298fc839"><td class="memItemLeft" align="right" valign="top"><a id="a014fd246834441f65441e88d298fc839"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a014fd246834441f65441e88d298fc839">array_n</a> (unsigned int d0,...)</td></tr>
<tr class="memdesc:a014fd246834441f65441e88d298fc839"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dim constructor. Allocates an array with N dimensions with maximum dimensions given by the parameters. <br /></td></tr>
<tr class="separator:a014fd246834441f65441e88d298fc839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e645e1a620903d12e4d00f99d58622c"><td class="memItemLeft" align="right" valign="top"><a id="a5e645e1a620903d12e4d00f99d58622c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a5e645e1a620903d12e4d00f99d58622c">array_n</a> (const <a class="el" href="classsisl_1_1array__n.html">array_n</a> &amp;obj)</td></tr>
<tr class="memdesc:a5e645e1a620903d12e4d00f99d58622c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a5e645e1a620903d12e4d00f99d58622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e1f1e74ed7f364ea222d56db5a423c"><td class="memItemLeft" align="right" valign="top"><a id="a50e1f1e74ed7f364ea222d56db5a423c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a50e1f1e74ed7f364ea222d56db5a423c">~array_n</a> ()</td></tr>
<tr class="memdesc:a50e1f1e74ed7f364ea222d56db5a423c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor Frees all memory used by this array. <br /></td></tr>
<tr class="separator:a50e1f1e74ed7f364ea222d56db5a423c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e89fa53677f239480a7766bc56caf7"><td class="memItemLeft" align="right" valign="top"><a id="ae8e89fa53677f239480a7766bc56caf7"></a>
<a class="el" href="classsisl_1_1array__n.html">array_n</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsisl_1_1array__n.html">array_n</a> &amp;obj)</td></tr>
<tr class="separator:ae8e89fa53677f239480a7766bc56caf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f13ba676e526aa5ed2814514685dc0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a89f13ba676e526aa5ed2814514685dc0">linear_index</a> (unsigned int d0,...) const</td></tr>
<tr class="separator:a89f13ba676e526aa5ed2814514685dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10bc825e1ab2bce68b9da0f98be3f1b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#ad10bc825e1ab2bce68b9da0f98be3f1b">linear_index</a> (unsigned int d0, va_list vl) const</td></tr>
<tr class="separator:ad10bc825e1ab2bce68b9da0f98be3f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04888819bc3567f52f52bdccdecd7e5c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a04888819bc3567f52f52bdccdecd7e5c">linear_index</a> (unsigned int *idx) const</td></tr>
<tr class="separator:a04888819bc3567f52f52bdccdecd7e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa1d22e81493e308a6ad66a5100ca43"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a1fa1d22e81493e308a6ad66a5100ca43">operator()</a> (unsigned int d0,...)</td></tr>
<tr class="separator:a1fa1d22e81493e308a6ad66a5100ca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9630d1014796a2dc2a6fe08f94841115"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a9630d1014796a2dc2a6fe08f94841115">operator()</a> (unsigned int d0,...) const</td></tr>
<tr class="separator:a9630d1014796a2dc2a6fe08f94841115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e63f670871d57e28133b212b94a0fc"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a33e63f670871d57e28133b212b94a0fc">operator()</a> (unsigned int *d)</td></tr>
<tr class="separator:a33e63f670871d57e28133b212b94a0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6080746c8b0be2377d391b9cc4c8cf4d"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a6080746c8b0be2377d391b9cc4c8cf4d">operator()</a> (unsigned int *d) const</td></tr>
<tr class="separator:a6080746c8b0be2377d391b9cc4c8cf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37afb07dd00ec3770758aca57c5e1f42"><td class="memItemLeft" align="right" valign="top"><a id="a37afb07dd00ec3770758aca57c5e1f42"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a37afb07dd00ec3770758aca57c5e1f42">has_value</a> (unsigned int d0,...) const</td></tr>
<tr class="memdesc:a37afb07dd00ec3770758aca57c5e1f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an index has a value For a multidimensional index, this returns whether or not that index has a value. The value at that index will always be readable, use this to know whether or not it's a true value, or an automatically generated value. <br /></td></tr>
<tr class="separator:a37afb07dd00ec3770758aca57c5e1f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54507c52f966f7a923a64cb509a09b56"><td class="memItemLeft" align="right" valign="top"><a id="a54507c52f966f7a923a64cb509a09b56"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a54507c52f966f7a923a64cb509a09b56">has_value</a> (unsigned int *d) const</td></tr>
<tr class="memdesc:a54507c52f966f7a923a64cb509a09b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an index has a value For a multidimensional index, this returns whether or not that index has a value. The value at that index will always be readable, use this to know whether or not it's a true value, or an automatically generated value. <br /></td></tr>
<tr class="separator:a54507c52f966f7a923a64cb509a09b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cb0c98a773ce6e2c4a1315c1cc0a87"><td class="memItemLeft" align="right" valign="top"><a id="a45cb0c98a773ce6e2c4a1315c1cc0a87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#a45cb0c98a773ce6e2c4a1315c1cc0a87">dump_to_stream</a> (std::ofstream &amp;stream) const</td></tr>
<tr class="memdesc:a45cb0c98a773ce6e2c4a1315c1cc0a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps this array to a file stream at its current index. <br /></td></tr>
<tr class="separator:a45cb0c98a773ce6e2c4a1315c1cc0a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5a844143174cd0b56d04e82893672d"><td class="memItemLeft" align="right" valign="top"><a id="abf5a844143174cd0b56d04e82893672d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html#abf5a844143174cd0b56d04e82893672d">read_from_stream</a> (std::ifstream &amp;stream)</td></tr>
<tr class="memdesc:abf5a844143174cd0b56d04e82893672d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a filestream. <br /></td></tr>
<tr class="separator:abf5a844143174cd0b56d04e82893672d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, int N, class Allocator = std::allocator&lt;T&gt;&gt;<br />
class sisl::array_n&lt; T, N, Allocator &gt;</h3>

<p>An n-dimensional array. This class abstracts away the concept of an n-dimensional array, it should be easy to create an array of type T on N dimensions. This is useful as it often ends up being the case that many integer sampling lattices can be broken down into interleaved Cartesian grids. At the end of the day, this implementation flattens the representation down onto dense linear memory. </p>
<p>However, if your data are sparse, you may benefit from the sparse array class in <a class="el" href="sparse__array_8hpp_source.html">sparse_array.hpp</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a89f13ba676e526aa5ed2814514685dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f13ba676e526aa5ed2814514685dc0">&#9670;&nbsp;</a></span>linear_index() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classsisl_1_1array__n.html">sisl::array_n</a>&lt; T, N, Allocator &gt;::linear_index </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Returns a unique index for this index. This returns a unique index for a point index, this should generally be an index between 0 and max_dim_1*max_dim_2*...*max_dim_N - 1. </p>

</div>
</div>
<a id="ad10bc825e1ab2bce68b9da0f98be3f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10bc825e1ab2bce68b9da0f98be3f1b">&#9670;&nbsp;</a></span>linear_index() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classsisl_1_1array__n.html">sisl::array_n</a>&lt; T, N, Allocator &gt;::linear_index </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>vl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Returns a unique index for this index. This returns a unique index for a point index, this should generally be an index between 0 and max_dim_1*max_dim_2*...*max_dim_N - 1. </p>

</div>
</div>
<a id="a04888819bc3567f52f52bdccdecd7e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04888819bc3567f52f52bdccdecd7e5c">&#9670;&nbsp;</a></span>linear_index() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classsisl_1_1array__n.html">sisl::array_n</a>&lt; T, N, Allocator &gt;::linear_index </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Returns a unique index for this index. This returns a unique index for a point index, this should generally be an index between 0 and max_dim_1*max_dim_2*...*max_dim_N - 1. </p>

</div>
</div>
<a id="a1fa1d22e81493e308a6ad66a5100ca43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa1d22e81493e308a6ad66a5100ca43">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classsisl_1_1array__n.html">sisl::array_n</a>&lt; T, N, Allocator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Accessor functions. Access a value in the array, returns a reference so it is possible to write to indices via this overload. </p>

</div>
</div>
<a id="a9630d1014796a2dc2a6fe08f94841115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9630d1014796a2dc2a6fe08f94841115">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classsisl_1_1array__n.html">sisl::array_n</a>&lt; T, N, Allocator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Accessor functions. Access a value in the array, returns a reference so it is possible to write to indices via this overload. </p>

</div>
</div>
<a id="a33e63f670871d57e28133b212b94a0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e63f670871d57e28133b212b94a0fc">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classsisl_1_1array__n.html">sisl::array_n</a>&lt; T, N, Allocator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Accessor functions. Access a value in the array, returns a reference so it is possible to write to indices via this overload. </p>

</div>
</div>
<a id="a6080746c8b0be2377d391b9cc4c8cf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6080746c8b0be2377d391b9cc4c8cf4d">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classsisl_1_1array__n.html">sisl::array_n</a>&lt; T, N, Allocator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Accessor functions. Access a value in the array, returns a reference so it is possible to write to indices via this overload. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/joshuahoracsek/Projects/sisl_redux/include/sisl/memory/<a class="el" href="array_8hpp_source.html">array.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

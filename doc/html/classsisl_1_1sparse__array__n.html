<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Shift Invariant Space Library (SISL): sisl::sparse_array_n&lt; T, N, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shift Invariant Space Library (SISL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesisl.html">sisl</a></li><li class="navelem"><a class="el" href="classsisl_1_1sparse__array__n.html">sparse_array_n</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsisl_1_1sparse__array__n-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sisl::sparse_array_n&lt; T, N, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An n-dimensional sparese array. This class abstracts away the concept of an n-dimensional array, it should be easy to create an array of type T on N dimensions. It differes from an array in that, when instantiated, it consumes no memory. When you begin to fill cells of the array with data, only then does memory begin to fill up. Accessing a cell without data returns "defaultValue", which is set in the constructor.  
 <a href="classsisl_1_1sparse__array__n.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sparse__array_8hpp_source.html">sparse_array.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sisl::sparse_array_n&lt; T, N, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsisl_1_1sparse__array__n__inherit__graph.png" border="0" usemap="#sisl_1_1sparse__array__n_3_01T_00_01N_00_01Allocator_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="sisl_1_1sparse__array__n_3_01T_00_01N_00_01Allocator_01_4_inherit__map" id="sisl_1_1sparse__array__n_3_01T_00_01N_00_01Allocator_01_4_inherit__map">
<area shape="rect" id="node2" href="classsisl_1_1array__n.html" title="An n&#45;dimensional array. This class abstracts away the concept of an n&#45;dimensional array..." alt="" coords="10,79,142,117"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sisl::sparse_array_n&lt; T, N, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsisl_1_1sparse__array__n__coll__graph.png" border="0" usemap="#sisl_1_1sparse__array__n_3_01T_00_01N_00_01Allocator_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="sisl_1_1sparse__array__n_3_01T_00_01N_00_01Allocator_01_4_coll__map" id="sisl_1_1sparse__array__n_3_01T_00_01N_00_01Allocator_01_4_coll__map">
<area shape="rect" id="node2" href="classsisl_1_1array__n.html" title="An n&#45;dimensional array. This class abstracts away the concept of an n&#45;dimensional array..." alt="" coords="10,79,142,117"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8c957cdf94a178f0d77c1c3c374f1f91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a8c957cdf94a178f0d77c1c3c374f1f91">sparse_array_n</a> (const Allocator &amp;a=Allocator())</td></tr>
<tr class="separator:a8c957cdf94a178f0d77c1c3c374f1f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd76d3fbb0e923e2b28cfba1c675482b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#afd76d3fbb0e923e2b28cfba1c675482b">sparse_array_n</a> (const Allocator &amp;a, const T &amp;dv, unsigned int d0,...)</td></tr>
<tr class="separator:afd76d3fbb0e923e2b28cfba1c675482b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132fb2f99e33ea6c34129eb1a02523f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a3132fb2f99e33ea6c34129eb1a02523f">sparse_array_n</a> (const T &amp;dv, unsigned int d0,...)</td></tr>
<tr class="separator:a3132fb2f99e33ea6c34129eb1a02523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cffd9aaa7d7ea15fdc5071dd3ddbac7"><td class="memItemLeft" align="right" valign="top"><a id="a8cffd9aaa7d7ea15fdc5071dd3ddbac7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_array_n</b> (const T &amp;dv, unsigned int *d)</td></tr>
<tr class="separator:a8cffd9aaa7d7ea15fdc5071dd3ddbac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae639c5c814a4649fcfa5ea2616e51f12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#ae639c5c814a4649fcfa5ea2616e51f12">~sparse_array_n</a> ()</td></tr>
<tr class="separator:ae639c5c814a4649fcfa5ea2616e51f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4418f97d93ce2a6cef4639ed371ee47e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a4418f97d93ce2a6cef4639ed371ee47e">linear_index</a> (unsigned int d0,...) const</td></tr>
<tr class="separator:a4418f97d93ce2a6cef4639ed371ee47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cf90a26a41032cfc091ebb45112d13"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a43cf90a26a41032cfc091ebb45112d13">linear_index</a> (unsigned int d0, va_list vl) const</td></tr>
<tr class="separator:a43cf90a26a41032cfc091ebb45112d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39aa26464a84f3895ab34b55f5925175"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a39aa26464a84f3895ab34b55f5925175">linear_index</a> (unsigned int *idx) const</td></tr>
<tr class="separator:a39aa26464a84f3895ab34b55f5925175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828d9cd11de929845c584d469b4cfb0d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a828d9cd11de929845c584d469b4cfb0d">operator()</a> (unsigned int d0,...)</td></tr>
<tr class="separator:a828d9cd11de929845c584d469b4cfb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b840c55a4225232fdc8852a1a068dd"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a37b840c55a4225232fdc8852a1a068dd">operator()</a> (unsigned int d0,...) const</td></tr>
<tr class="separator:a37b840c55a4225232fdc8852a1a068dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e3bb0965fa54371ad65e6c5cc10520"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a21e3bb0965fa54371ad65e6c5cc10520">operator()</a> (unsigned int *d)</td></tr>
<tr class="separator:a21e3bb0965fa54371ad65e6c5cc10520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ab70c556272a847c076ff5f3a2ad26"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#ad7ab70c556272a847c076ff5f3a2ad26">operator()</a> (unsigned int *d) const</td></tr>
<tr class="separator:ad7ab70c556272a847c076ff5f3a2ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db3ee8940017e21e3673641071f9654"><td class="memItemLeft" align="right" valign="top"><a id="a7db3ee8940017e21e3673641071f9654"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a7db3ee8940017e21e3673641071f9654">has_value</a> (unsigned int d0,...) const</td></tr>
<tr class="memdesc:a7db3ee8940017e21e3673641071f9654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an index has a value For a multidimensional index, this returns whether or not that index has a value. The value at that index will always be readable, use this to know whether or not it's a true value, or an automatically generated value. <br /></td></tr>
<tr class="separator:a7db3ee8940017e21e3673641071f9654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc06154d0a6c469cab565d68876e637"><td class="memItemLeft" align="right" valign="top"><a id="a7fc06154d0a6c469cab565d68876e637"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a7fc06154d0a6c469cab565d68876e637">has_value</a> (unsigned int *d) const</td></tr>
<tr class="memdesc:a7fc06154d0a6c469cab565d68876e637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an index has a value For a multidimensional index, this returns whether or not that index has a value. The value at that index will always be readable, use this to know whether or not it's a true value, or an automatically generated value. <br /></td></tr>
<tr class="separator:a7fc06154d0a6c469cab565d68876e637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45b35c8068495755175df44e8b3c117"><td class="memItemLeft" align="right" valign="top"><a id="aa45b35c8068495755175df44e8b3c117"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#aa45b35c8068495755175df44e8b3c117">dump_to_stream</a> (std::ofstream &amp;stream) const</td></tr>
<tr class="memdesc:aa45b35c8068495755175df44e8b3c117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps this array to a file stream at its current index. <br /></td></tr>
<tr class="separator:aa45b35c8068495755175df44e8b3c117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76553311b73e61d9abc06b615f9997d6"><td class="memItemLeft" align="right" valign="top"><a id="a76553311b73e61d9abc06b615f9997d6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html#a76553311b73e61d9abc06b615f9997d6">read_from_stream</a> (std::ifstream &amp;stream)</td></tr>
<tr class="memdesc:a76553311b73e61d9abc06b615f9997d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a filestream. <br /></td></tr>
<tr class="separator:a76553311b73e61d9abc06b615f9997d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, int N, class Allocator = std::allocator&lt;T&gt;&gt;<br />
class sisl::sparse_array_n&lt; T, N, Allocator &gt;</h3>

<p>An n-dimensional sparese array. This class abstracts away the concept of an n-dimensional array, it should be easy to create an array of type T on N dimensions. It differes from an array in that, when instantiated, it consumes no memory. When you begin to fill cells of the array with data, only then does memory begin to fill up. Accessing a cell without data returns "defaultValue", which is set in the constructor. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8c957cdf94a178f0d77c1c3c374f1f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c957cdf94a178f0d77c1c3c374f1f91">&#9670;&nbsp;</a></span>sparse_array_n() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::<a class="el" href="classsisl_1_1sparse__array__n.html">sparse_array_n</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>Allocator()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. Default constructor, allocates nothing. </p>

</div>
</div>
<a id="afd76d3fbb0e923e2b28cfba1c675482b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd76d3fbb0e923e2b28cfba1c675482b">&#9670;&nbsp;</a></span>sparse_array_n() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::<a class="el" href="classsisl_1_1sparse__array__n.html">sparse_array_n</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>N-dim constructor. Allocates an array with N dimensions with maximum dimensions given by the parameters. </p>

</div>
</div>
<a id="a3132fb2f99e33ea6c34129eb1a02523f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3132fb2f99e33ea6c34129eb1a02523f">&#9670;&nbsp;</a></span>sparse_array_n() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::<a class="el" href="classsisl_1_1sparse__array__n.html">sparse_array_n</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>N-dim constructor. Allocates an array with N dimensions with maximum dimensions given by the parameters. </p>

</div>
</div>
<a id="ae639c5c814a4649fcfa5ea2616e51f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae639c5c814a4649fcfa5ea2616e51f12">&#9670;&nbsp;</a></span>~sparse_array_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::~<a class="el" href="classsisl_1_1sparse__array__n.html">sparse_array_n</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>N-dim constructor. Allocates an array with N dimensions with maximum dimensions given by the parameters. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4418f97d93ce2a6cef4639ed371ee47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4418f97d93ce2a6cef4639ed371ee47e">&#9670;&nbsp;</a></span>linear_index() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::linear_index </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Returns a unique index for this index. This returns a unique index for a point index, this should generally be an index between 0 and max_dim_1*max_dim_2*...*max_dim_N - 1. </p>

</div>
</div>
<a id="a43cf90a26a41032cfc091ebb45112d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cf90a26a41032cfc091ebb45112d13">&#9670;&nbsp;</a></span>linear_index() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::linear_index </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>vl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Returns a unique index for this index. This returns a unique index for a point index, this should generally be an index between 0 and max_dim_1*max_dim_2*...*max_dim_N - 1. </p>

</div>
</div>
<a id="a39aa26464a84f3895ab34b55f5925175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39aa26464a84f3895ab34b55f5925175">&#9670;&nbsp;</a></span>linear_index() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::linear_index </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Returns a unique index for this index. This returns a unique index for a point index, this should generally be an index between 0 and max_dim_1*max_dim_2*...*max_dim_N - 1. </p>

</div>
</div>
<a id="a828d9cd11de929845c584d469b4cfb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828d9cd11de929845c584d469b4cfb0d">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Accessor functions. Access a value in the array, returns a reference so it is possible to write to indices via this overload. </p>

</div>
</div>
<a id="a37b840c55a4225232fdc8852a1a068dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b840c55a4225232fdc8852a1a068dd">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Accessor functions. Access a value in the array, returns a reference so it is possible to write to indices via this overload. </p>

</div>
</div>
<a id="a21e3bb0965fa54371ad65e6c5cc10520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e3bb0965fa54371ad65e6c5cc10520">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Accessor functions. Access a value in the array, returns a reference so it is possible to write to indices via this overload. </p>

</div>
</div>
<a id="ad7ab70c556272a847c076ff5f3a2ad26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ab70c556272a847c076ff5f3a2ad26">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N, class Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classsisl_1_1sparse__array__n.html">sisl::sparse_array_n</a>&lt; T, N, Allocator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/brief Accessor functions. Access a value in the array, returns a reference so it is possible to write to indices via this overload. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/joshuahoracsek/Projects/sisl_redux/include/sisl/memory/<a class="el" href="sparse__array_8hpp_source.html">sparse_array.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

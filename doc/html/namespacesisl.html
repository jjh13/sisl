<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Shift Invariant Space Library (SISL): sisl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shift Invariant Space Library (SISL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sisl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Global namespace for all of SISL.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesisl_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl_1_1test.html">test</a></td></tr>
<tr class="memdesc:namespacesisl_1_1test"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for most test functions within SISL, this includes anything that would be useful for verification of experimental results. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesisl_1_1utility"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl_1_1utility.html">utility</a></td></tr>
<tr class="memdesc:namespacesisl_1_1utility"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for utility functions, anything that's generally helpful, but not related to shift invariant spaces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1array__n.html">array_n</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An n-dimensional array. This class abstracts away the concept of an n-dimensional array, it should be easy to create an array of type T on N dimensions. This is useful as it often ends up being the case that many integer sampling lattices can be broken down into interleaved Cartesian grids. At the end of the day, this implementation flattens the representation down onto dense linear memory.  <a href="classsisl_1_1array__n.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1base__lattice.html">base_lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base abstract lattice class. Defines the base class for a lattice, which are by definition subsets of Z^n.  <a href="classsisl_1_1base__lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1basis__function.html">basis_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract definition of a basis function. Provides an interface that any basis function of a shift invariant space must adhere to. This also provides the heavy lifting code for a ``brute force'' convolution sum. <a class="el" href="classsisl_1_1tp__linear.html" title="Tensor product linear basis function. Tensor product linear basis function. On the planar and cubic C...">tp_linear</a> is a good example of how to implement basis functions.  <a href="classsisl_1_1basis__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1bcc__quintic__rdo.html">bcc_quintic_rdo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quintic BCC basis function.  <a href="classsisl_1_1bcc__quintic__rdo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1body__centered__cubic.html">body_centered_cubic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the body centered cubic lattice in 3d.  <a href="classsisl_1_1body__centered__cubic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1cartesian__cubic.html">cartesian_cubic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized cubic Cartesian lattice class.  <a href="classsisl_1_1cartesian__cubic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1cartesian__planar.html">cartesian_planar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized Cartesian planar lattice class.  <a href="classsisl_1_1cartesian__planar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1function.html">function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for a function. Defines a function that is valid over all R^n, it's up to the underlying implementation to decide how those values map to real values.  <a href="classsisl_1_1function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1nearest__neighbor.html">nearest_neighbor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbor interpolation for any lattice. Simply finds the nearest lattice site and returns the value at that site. This class doesn't implement phi or dphi functions, as one would need to know the lattice a-priori for those, and this class structure isn't sophisticated enough to facilitate that.  <a href="classsisl_1_1nearest__neighbor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsisl_1_1plane.html">plane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D plane class.  <a href="structsisl_1_1plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsisl_1_1ray.html">ray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ray in space.  <a href="structsisl_1_1ray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1si__function.html">si_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a lattice and a generating function.  <a href="classsisl_1_1si__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1sparse__array__n.html">sparse_array_n</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An n-dimensional sparese array. This class abstracts away the concept of an n-dimensional array, it should be easy to create an array of type T on N dimensions. It differes from an array in that, when instantiated, it consumes no memory. When you begin to fill cells of the array with data, only then does memory begin to fill up. Accessing a cell without data returns "defaultValue", which is set in the constructor.  <a href="classsisl_1_1sparse__array__n.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1tp__cubic.html">tp_cubic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor product cubic spline.  <a href="classsisl_1_1tp__cubic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1tp__cubic__imom.html">tp_cubic_imom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor product cubic interpolating MOM.  <a href="classsisl_1_1tp__cubic__imom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor product linear basis function. Tensor product linear basis function. On the planar and cubic Cartesian lattices, we have FAST_BASES which correspond to bilinear and trilinear interpolation.  <a href="classsisl_1_1tp__linear.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1tp__quadratic.html">tp_quadratic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor product quadratic spline.  <a href="classsisl_1_1tp__quadratic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsisl_1_1triangle.html">triangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangle in 3D space.  <a href="structsisl_1_1triangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsisl_1_1vertex3.html">vertex3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D vertex.  <a href="structsisl_1_1vertex3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsisl_1_1zp3__element.html">zp3_element</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2069bd5374a9be042ff3ce3306d41e1a"><td class="memItemLeft" align="right" valign="top"><a id="a2069bd5374a9be042ff3ce3306d41e1a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl.html#a2069bd5374a9be042ff3ce3306d41e1a">vector</a> = Eigen::Matrix&lt; sisl_float, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a2069bd5374a9be042ff3ce3306d41e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">dynamically sized (mathematical) vector datatype <br /></td></tr>
<tr class="separator:a2069bd5374a9be042ff3ce3306d41e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf80b1234035c1dbd3d570c96c6a63a"><td class="memItemLeft" align="right" valign="top"><a id="afaf80b1234035c1dbd3d570c96c6a63a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl.html#afaf80b1234035c1dbd3d570c96c6a63a">point</a> = Eigen::Matrix&lt; sisl_float, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:afaf80b1234035c1dbd3d570c96c6a63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">dynamically size point datatype <br /></td></tr>
<tr class="separator:afaf80b1234035c1dbd3d570c96c6a63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef12d285ca3e626c05abbdec1f8a679"><td class="memItemLeft" align="right" valign="top"><a id="a2ef12d285ca3e626c05abbdec1f8a679"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl.html#a2ef12d285ca3e626c05abbdec1f8a679">transform</a> = Eigen::Matrix&lt; sisl_float, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a2ef12d285ca3e626c05abbdec1f8a679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically sized transform (i.e. matrix) <br /></td></tr>
<tr class="separator:a2ef12d285ca3e626c05abbdec1f8a679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa043f4ef2b36e60d18bb37009e3aeed2"><td class="memItemLeft" align="right" valign="top"><a id="aa043f4ef2b36e60d18bb37009e3aeed2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl.html#aa043f4ef2b36e60d18bb37009e3aeed2">rgb_color</a> = Eigen::Matrix&lt; sisl_float, 3, 1 &gt;</td></tr>
<tr class="memdesc:aa043f4ef2b36e60d18bb37009e3aeed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed size 3-vector for holding colours. <br /></td></tr>
<tr class="separator:aa043f4ef2b36e60d18bb37009e3aeed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd6b969b6b4f5c56b84502d3f561636"><td class="memItemLeft" align="right" valign="top"><a id="acbd6b969b6b4f5c56b84502d3f561636"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl.html#acbd6b969b6b4f5c56b84502d3f561636">rgba_color</a> = Eigen::Matrix&lt; sisl_float, 4, 1 &gt;</td></tr>
<tr class="memdesc:acbd6b969b6b4f5c56b84502d3f561636"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed size 4-vector for holding colours and an alpha channel. <br /></td></tr>
<tr class="separator:acbd6b969b6b4f5c56b84502d3f561636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd18feee4026583db6185df2b25434aa"><td class="memItemLeft" align="right" valign="top"><a id="acd18feee4026583db6185df2b25434aa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl.html#acd18feee4026583db6185df2b25434aa">lattice_site</a> = Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:acd18feee4026583db6185df2b25434aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lattice_site are integer tuples (vectors) <br /></td></tr>
<tr class="separator:acd18feee4026583db6185df2b25434aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc492e1c166a136d08b283394d81cd71"><td class="memItemLeft" align="right" valign="top"><a id="adc492e1c166a136d08b283394d81cd71"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl.html#adc492e1c166a136d08b283394d81cd71">int_tuple</a> = Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:adc492e1c166a136d08b283394d81cd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer tuples (vectors) <br /></td></tr>
<tr class="separator:adc492e1c166a136d08b283394d81cd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aaf1f41d23ed37dacaa4c9f1bb6d3324f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl.html#aaf1f41d23ed37dacaa4c9f1bb6d3324f">LatticeExtensionType</a> { <br />
&#160;&#160;<a class="el" href="namespacesisl.html#aaf1f41d23ed37dacaa4c9f1bb6d3324fadfcb36de23898505e7d6a7118c886659">InvalidAccess</a> = -1, 
<a class="el" href="namespacesisl.html#aaf1f41d23ed37dacaa4c9f1bb6d3324fac0e9f82838a1a73b81d84d19571341a1">ForceZero</a> = 0, 
<a class="el" href="namespacesisl.html#aaf1f41d23ed37dacaa4c9f1bb6d3324fae2c9e90c80ef46b1a6b3b5c61dd8392e">Periodic</a>, 
<a class="el" href="namespacesisl.html#aaf1f41d23ed37dacaa4c9f1bb6d3324faa83636be87d2bc6798c54dbafe922e39">Extend_Even_Even</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesisl.html#aaf1f41d23ed37dacaa4c9f1bb6d3324fa4557b0af0e76c30cf1ce9c7be615183c">Extend_Even_Odd</a>, 
<a class="el" href="namespacesisl.html#aaf1f41d23ed37dacaa4c9f1bb6d3324fa7f5a23d007bce2170e4aa405b7a0829e">Extend_Odd_Even</a>, 
<a class="el" href="namespacesisl.html#aaf1f41d23ed37dacaa4c9f1bb6d3324fa1ba3dc19cdffc9a67e046e50e1e64187">Extend_Odd_Odd</a>
<br />
 }<tr class="memdesc:aaf1f41d23ed37dacaa4c9f1bb6d3324f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how a lattice should be extended. Useful for data processing that requires perodic behaviour.  <a href="namespacesisl.html#aaf1f41d23ed37dacaa4c9f1bb6d3324f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aaf1f41d23ed37dacaa4c9f1bb6d3324f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af139f6f74488292ae48c0d71eaa5d4f1"><td class="memItemLeft" align="right" valign="top"><a id="af139f6f74488292ae48c0d71eaa5d4f1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl.html#af139f6f74488292ae48c0d71eaa5d4f1">LatticeRegionShift</a> { <br />
&#160;&#160;<b>NoShift</b> = 0, 
<b>Shift</b>, 
<b>None_Shift</b>, 
<b>Shift_None</b>, 
<br />
&#160;&#160;<b>Shift_Shift</b>
<br />
 }<tr class="memdesc:af139f6f74488292ae48c0d71eaa5d4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how a lattice extension gets shifted. <br /></td></tr>
</td></tr>
<tr class="separator:af139f6f74488292ae48c0d71eaa5d4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb05df69c6b8f6d31074a5f4cec4baeb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesisl.html#acb05df69c6b8f6d31074a5f4cec4baeb">e_datatype</a> { <br />
&#160;&#160;<b>SDT_UNKNOWN</b> = -1, 
<b>SDT_UINT8</b> = 0, 
<b>SDT_UINT16</b> = 1, 
<b>SDT_UINT32</b> = 2, 
<br />
&#160;&#160;<b>SDT_FLOAT</b> = 3, 
<b>SDT_DOUBLE</b> = 4
<br />
 }</td></tr>
<tr class="separator:acb05df69c6b8f6d31074a5f4cec4baeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7295912c88c93a730de6a93f9bfff854"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7295912c88c93a730de6a93f9bfff854"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesisl.html#a7295912c88c93a730de6a93f9bfff854">__fast_planar_tp_linear__</a> (const <a class="el" href="namespacesisl.html#a2069bd5374a9be042ff3ce3306d41e1a">vector</a> &amp;p, const <a class="el" href="classsisl_1_1cartesian__planar.html">cartesian_planar</a>&lt; T &gt; *lattice)</td></tr>
<tr class="separator:a7295912c88c93a730de6a93f9bfff854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88de527ba071c0203e68dde0caf2257a"><td class="memItemLeft" align="right" valign="top"><a id="a88de527ba071c0203e68dde0caf2257a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__planar.html">cartesian_planar</a>, <a class="el" href="namespacesisl.html#a7295912c88c93a730de6a93f9bfff854">__fast_planar_tp_linear__</a>, 2, unsigned char)</td></tr>
<tr class="separator:a88de527ba071c0203e68dde0caf2257a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38991de77fa5cd8ecbd9e3bf6f6a1c59"><td class="memItemLeft" align="right" valign="top"><a id="a38991de77fa5cd8ecbd9e3bf6f6a1c59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__planar.html">cartesian_planar</a>, <a class="el" href="namespacesisl.html#a7295912c88c93a730de6a93f9bfff854">__fast_planar_tp_linear__</a>, 2, char)</td></tr>
<tr class="separator:a38991de77fa5cd8ecbd9e3bf6f6a1c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7efd7a61d967125eb5a75b37371a1bc"><td class="memItemLeft" align="right" valign="top"><a id="ae7efd7a61d967125eb5a75b37371a1bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__planar.html">cartesian_planar</a>, <a class="el" href="namespacesisl.html#a7295912c88c93a730de6a93f9bfff854">__fast_planar_tp_linear__</a>, 2, short)</td></tr>
<tr class="separator:ae7efd7a61d967125eb5a75b37371a1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3efa8fdefe2c747c5f38181f71a469"><td class="memItemLeft" align="right" valign="top"><a id="a8d3efa8fdefe2c747c5f38181f71a469"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__planar.html">cartesian_planar</a>, <a class="el" href="namespacesisl.html#a7295912c88c93a730de6a93f9bfff854">__fast_planar_tp_linear__</a>, 2, int)</td></tr>
<tr class="separator:a8d3efa8fdefe2c747c5f38181f71a469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73583c8d98b61ea4e01b1c8418765e82"><td class="memItemLeft" align="right" valign="top"><a id="a73583c8d98b61ea4e01b1c8418765e82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__planar.html">cartesian_planar</a>, <a class="el" href="namespacesisl.html#a7295912c88c93a730de6a93f9bfff854">__fast_planar_tp_linear__</a>, 2, float)</td></tr>
<tr class="separator:a73583c8d98b61ea4e01b1c8418765e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6226cce64b0dc23d509ea87b3953d04d"><td class="memItemLeft" align="right" valign="top"><a id="a6226cce64b0dc23d509ea87b3953d04d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__planar.html">cartesian_planar</a>, <a class="el" href="namespacesisl.html#a7295912c88c93a730de6a93f9bfff854">__fast_planar_tp_linear__</a>, 2, double)</td></tr>
<tr class="separator:a6226cce64b0dc23d509ea87b3953d04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41665c7664aae419e4fa4154c7b2acc8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a41665c7664aae419e4fa4154c7b2acc8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesisl.html#a41665c7664aae419e4fa4154c7b2acc8">__fast_cubic_tp_linear__</a> (const <a class="el" href="namespacesisl.html#a2069bd5374a9be042ff3ce3306d41e1a">vector</a> &amp;p, const <a class="el" href="classsisl_1_1cartesian__cubic.html">cartesian_cubic</a>&lt; T &gt; *lattice)</td></tr>
<tr class="separator:a41665c7664aae419e4fa4154c7b2acc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736191041ea567e08ff434e0f91efc88"><td class="memItemLeft" align="right" valign="top"><a id="a736191041ea567e08ff434e0f91efc88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__cubic.html">cartesian_cubic</a>, <a class="el" href="namespacesisl.html#a41665c7664aae419e4fa4154c7b2acc8">__fast_cubic_tp_linear__</a>, 3, unsigned char)</td></tr>
<tr class="separator:a736191041ea567e08ff434e0f91efc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d532da6f321398da173dc4df88e60bc"><td class="memItemLeft" align="right" valign="top"><a id="a6d532da6f321398da173dc4df88e60bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__cubic.html">cartesian_cubic</a>, <a class="el" href="namespacesisl.html#a41665c7664aae419e4fa4154c7b2acc8">__fast_cubic_tp_linear__</a>, 3, char)</td></tr>
<tr class="separator:a6d532da6f321398da173dc4df88e60bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3585cd21b92e4cb2331f3bb2bd841344"><td class="memItemLeft" align="right" valign="top"><a id="a3585cd21b92e4cb2331f3bb2bd841344"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__cubic.html">cartesian_cubic</a>, <a class="el" href="namespacesisl.html#a41665c7664aae419e4fa4154c7b2acc8">__fast_cubic_tp_linear__</a>, 3, short)</td></tr>
<tr class="separator:a3585cd21b92e4cb2331f3bb2bd841344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63757b79e857499d8a22c4352bda314"><td class="memItemLeft" align="right" valign="top"><a id="aa63757b79e857499d8a22c4352bda314"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__cubic.html">cartesian_cubic</a>, <a class="el" href="namespacesisl.html#a41665c7664aae419e4fa4154c7b2acc8">__fast_cubic_tp_linear__</a>, 3, int)</td></tr>
<tr class="separator:aa63757b79e857499d8a22c4352bda314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585e64aca67403ff6a314670d7d9b53a"><td class="memItemLeft" align="right" valign="top"><a id="a585e64aca67403ff6a314670d7d9b53a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__cubic.html">cartesian_cubic</a>, <a class="el" href="namespacesisl.html#a41665c7664aae419e4fa4154c7b2acc8">__fast_cubic_tp_linear__</a>, 3, float)</td></tr>
<tr class="separator:a585e64aca67403ff6a314670d7d9b53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c510cfd2fd41c64ea57a3e52e8412b8"><td class="memItemLeft" align="right" valign="top"><a id="a0c510cfd2fd41c64ea57a3e52e8412b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FAST_BASIS_SPECIALIZATION</b> (<a class="el" href="classsisl_1_1tp__linear.html">tp_linear</a>, <a class="el" href="classsisl_1_1cartesian__cubic.html">cartesian_cubic</a>, <a class="el" href="namespacesisl.html#a41665c7664aae419e4fa4154c7b2acc8">__fast_cubic_tp_linear__</a>, 3, double)</td></tr>
<tr class="separator:a0c510cfd2fd41c64ea57a3e52e8412b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7226c23f2b3fc3bfc30594977d6dec3f"><td class="memTemplParams" colspan="2"><a id="a7226c23f2b3fc3bfc30594977d6dec3f"></a>
template&lt;class O , class I , class BF &gt; </td></tr>
<tr class="memitem:a7226c23f2b3fc3bfc30594977d6dec3f"><td class="memTemplItemLeft" align="right" valign="top">regular_function_space&lt; CC_LATTICE(O, I), BF, O, I, 2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_2d_raw_file</b> (int rx, int ry, I scale_x, I scale_y, const std::string &amp;file, const <a class="el" href="namespacesisl.html#acb05df69c6b8f6d31074a5f4cec4baeb">e_datatype</a> &amp;type)</td></tr>
<tr class="separator:a7226c23f2b3fc3bfc30594977d6dec3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0589ffc20d038475dc0b502cbcbfdf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aac0589ffc20d038475dc0b502cbcbfdf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesisl.html#aac0589ffc20d038475dc0b502cbcbfdf">sample_on_lattice</a> (const <a class="el" href="namespacesisl.html#a2069bd5374a9be042ff3ce3306d41e1a">vector</a> &amp;origin, const <a class="el" href="namespacesisl.html#a2069bd5374a9be042ff3ce3306d41e1a">vector</a> &amp;extent, <a class="el" href="classsisl_1_1base__lattice.html">base_lattice</a>&lt; T &gt; *l, <a class="el" href="classsisl_1_1function.html">function</a> *f)</td></tr>
<tr class="separator:aac0589ffc20d038475dc0b502cbcbfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Global namespace for all of SISL. </p>
<p><a class="el" href="quintic__rdo_8hpp_source.html">quintic_rdo.hpp</a></p>
<p>Default evaluation code for the spline defined by [-1 1 1 -1 -1 1 1 -1] [ 1 -1 1 -1 1 -1 1 -1] [ 1 1 -1 -1 1 1 -1 -1] Auto-generated from the Sage worksheet.</p>
<p><a class="el" href="zp3__element_8hpp_source.html">zp3_element.hpp</a></p>
<p>Default evaluation code for the spline defined by [-1 1 1 -1 1 0 0] [ 1 -1 1 -1 0 1 0] [ 1 1 -1 -1 0 0 1] Auto-generated from the Sage worksheet.</p>
<p><a class="el" href="nearest__neighbor_8hpp_source.html">nearest_neighbor.hpp</a> Nearest neighbor interpolation on any lattice, in any dimension.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="tp__cubic_8hpp_source.html">tp_cubic.hpp</a> Implements the tensor product cubic b_spline in 'N' dimensions.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p>tp_cubic_imom.h Implements the tensor product interpolating cubic imom in 'N' dimensions.</p>
<p>b_3imom(x) = b_3(x) - 1/6 d^2/dx^2 b_3(x)</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="tp__linear_8hpp_source.html">tp_linear.hpp</a> Implements the tensor product linear b_spline in 'N' dimensions.</p>
<p>Box spline generating matrix: [1, 0, 0] [0, 1, 0] [0, 0, 1]</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="tp__quadratic_8hpp_source.html">tp_quadratic.hpp</a> Implements the tensor product quadratic b_spline in 'N' dimensions.</p>
<p>Box spline generating matrix: [1, 0, 0, 1, 0, 0] [0, 1, 0, 0, 1, 0] [0, 0, 1, 0, 0, 1]</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="base__function_8hpp_source.html">base_function.hpp</a></p>
<p>Abstract class that defines the basic structure of a function in SISL. Basically, all functions are mappings from R^n to R, and only need to provide a means of reconstructing values from that function space.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="si__function_8hpp_source.html">si_function.hpp</a></p>
<p>This file defines functions from a shift invariant space. We call these Shift Invariant Functions (si_functions), which is a slight abuse of naming to mean that they come from shift invariant spaces.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="cartesian__planar_8hpp_source.html">cartesian_planar.hpp</a></p>
<p>A specialized implementation of the planar Cartesian lattice.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="body__centered__cubic_8hpp_source.html">body_centered_cubic.hpp</a></p>
<p>A specialized implementation of the A*_3 lattice.</p>
<p>Horacsek</p>
<p><a class="el" href="cartesian__cubic_8hpp_source.html">cartesian_cubic.hpp</a></p>
<p>A specialized implementation of the Cartesian cubic lattice. The general implemnetation exists in sisl/n_cartesian.hpp</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="base__lattice_8hpp_source.html">base_lattice.hpp</a> Defines the abstract class for a lattice.</p>
<p>Lattices are basically containers for values of a generic type T. Specialized implementations can often leverage faster implementations of certain method implementations.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="array_8hpp_source.html">array.hpp</a></p>
<p>This class defines a general abstraction to multi-dimensional arrays. Basically, we want a templated base class to define how access should be implemented &ndash; this builds a base for the rules that potentially more sparse representations use.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="sparse__array_8hpp_source.html">sparse_array.hpp</a></p>
<p>This class defines another abstraction to multi-dimensional arrays. This is much like <a class="el" href="array_8hpp_source.html">array.hpp</a>, but uses a dictionary to sparesely store values.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="marschner__lobb_8hpp_source.html">marschner_lobb.hpp</a> Defines the marschner-lobb test function as a descendent of the function abstract class.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="test__window_8hpp_source.html">test_window.hpp</a></p>
<p>Defines a test window function in 3D.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="iso__surface_8hpp_source.html">iso_surface.hpp</a> A marching cubes implementation for functions. Any function that inherits from fuction in <a class="el" href="base__function_8hpp_source.html">base_function.hpp</a> can use this implementation to quickly output a mesh.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p><a class="el" href="ply__mesh_8hpp_source.html">ply_mesh.hpp</a> A very quick n' dirty implementation of a mesh writer. Mainly used to quickly output meshes from a marching algo.</p>
<dl class="section author"><dt>Author</dt><dd>Joshua Horacsek</dd></dl>
<p>TODO: Add a more sophisticated spatial data structure for duplicate vertex detection. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acb05df69c6b8f6d31074a5f4cec4baeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb05df69c6b8f6d31074a5f4cec4baeb">&#9670;&nbsp;</a></span>e_datatype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesisl.html#acb05df69c6b8f6d31074a5f4cec4baeb">sisl::e_datatype</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The various datatypes SISL can read, mainly used in the raw filetype reader </p>

</div>
</div>
<a id="aaf1f41d23ed37dacaa4c9f1bb6d3324f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1f41d23ed37dacaa4c9f1bb6d3324f">&#9670;&nbsp;</a></span>LatticeExtensionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesisl.html#aaf1f41d23ed37dacaa4c9f1bb6d3324f">sisl::LatticeExtensionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines how a lattice should be extended. Useful for data processing that requires perodic behaviour. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaf1f41d23ed37dacaa4c9f1bb6d3324fadfcb36de23898505e7d6a7118c886659"></a>InvalidAccess&#160;</td><td class="fielddoc"><p>All accesses outside of the lattice generate an exception. </p>
</td></tr>
<tr><td class="fieldname"><a id="aaf1f41d23ed37dacaa4c9f1bb6d3324fac0e9f82838a1a73b81d84d19571341a1"></a>ForceZero&#160;</td><td class="fielddoc"><p>All reads outside of the lattice return 0, writes generate an exception. </p>
</td></tr>
<tr><td class="fieldname"><a id="aaf1f41d23ed37dacaa4c9f1bb6d3324fae2c9e90c80ef46b1a6b3b5c61dd8392e"></a>Periodic&#160;</td><td class="fielddoc"><p>Periodic lattice. </p>
</td></tr>
<tr><td class="fieldname"><a id="aaf1f41d23ed37dacaa4c9f1bb6d3324faa83636be87d2bc6798c54dbafe922e39"></a>Extend_Even_Even&#160;</td><td class="fielddoc"><p>Even extension about origin, even extension about midpoint. </p>
</td></tr>
<tr><td class="fieldname"><a id="aaf1f41d23ed37dacaa4c9f1bb6d3324fa4557b0af0e76c30cf1ce9c7be615183c"></a>Extend_Even_Odd&#160;</td><td class="fielddoc"><p>Even extension about origin, odd extension about midpoint. </p>
</td></tr>
<tr><td class="fieldname"><a id="aaf1f41d23ed37dacaa4c9f1bb6d3324fa7f5a23d007bce2170e4aa405b7a0829e"></a>Extend_Odd_Even&#160;</td><td class="fielddoc"><p>odd extension about origin, even extension about midpoint </p>
</td></tr>
<tr><td class="fieldname"><a id="aaf1f41d23ed37dacaa4c9f1bb6d3324fa1ba3dc19cdffc9a67e046e50e1e64187"></a>Extend_Odd_Odd&#160;</td><td class="fielddoc"><p>odd extension about origin, even extension about midpoint </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a41665c7664aae419e4fa4154c7b2acc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41665c7664aae419e4fa4154c7b2acc8">&#9670;&nbsp;</a></span>__fast_cubic_tp_linear__()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double sisl::__fast_cubic_tp_linear__ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesisl.html#a2069bd5374a9be042ff3ce3306d41e1a">vector</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsisl_1_1cartesian__cubic.html">cartesian_cubic</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>lattice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension: 3 Lattice: Cartesian (cubic) In this case, we can just do a tri-linear interpolation of the values at the corners of a shifted voronoi cell. </p>

</div>
</div>
<a id="a7295912c88c93a730de6a93f9bfff854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7295912c88c93a730de6a93f9bfff854">&#9670;&nbsp;</a></span>__fast_planar_tp_linear__()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double sisl::__fast_planar_tp_linear__ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesisl.html#a2069bd5374a9be042ff3ce3306d41e1a">vector</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsisl_1_1cartesian__planar.html">cartesian_planar</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>lattice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension: 2 Lattice: Cartesian (planar) In this case, we can just do a bi-linear interpolation of the values at the corners of a shifted voronoi cell. </p>

</div>
</div>
<a id="aac0589ffc20d038475dc0b502cbcbfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0589ffc20d038475dc0b502cbcbfdf">&#9670;&nbsp;</a></span>sample_on_lattice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sisl::sample_on_lattice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesisl.html#a2069bd5374a9be042ff3ce3306d41e1a">vector</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesisl.html#a2069bd5374a9be042ff3ce3306d41e1a">vector</a> &amp;&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsisl_1_1base__lattice.html">base_lattice</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsisl_1_1function.html">function</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Samples a function on to any lattice note that this function may or may not be broken with the most recent convention change </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>where to start sampling </td></tr>
    <tr><td class="paramname">extent</td><td>cuboid volume to capture </td></tr>
    <tr><td class="paramname">l</td><td>lattice on which to sample </td></tr>
    <tr><td class="paramname">f</td><td>a fucntion to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

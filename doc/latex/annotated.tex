\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{class__fftwalloc}{\+\_\+fftwalloc$<$ T $>$} }{\pageref{class__fftwalloc}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1array__n}{sisl\+::array\+\_\+n$<$ T, N, Allocator $>$} \\*An n-\/dimensional array. This class abstracts away the concept of an n-\/dimensional array, it should be easy to create an array of type T on N dimensions. This is useful as it often ends up being the case that many integer sampling lattices can be broken down into interleaved Cartesian grids. At the end of the day, this implementation flattens the representation down onto dense linear memory }{\pageref{classsisl_1_1array__n}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1base__lattice}{sisl\+::base\+\_\+lattice$<$ T $>$} \\*Base abstract lattice class. Defines the base class for a lattice, which are by definition subsets of Z$^\wedge$n }{\pageref{classsisl_1_1base__lattice}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1basis__function}{sisl\+::basis\+\_\+function} \\*Abstract definition of a basis function. Provides an interface that any basis function of a shift invariant space must adhere to. This also provides the heavy lifting code for a ``brute force\textquotesingle{}\textquotesingle{} convolution sum. \hyperlink{classsisl_1_1tp__linear}{tp\+\_\+linear} is a good example of how to implement basis functions }{\pageref{classsisl_1_1basis__function}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1bcc__quintic__rdo}{sisl\+::bcc\+\_\+quintic\+\_\+rdo} \\*Quintic B\+CC basis function }{\pageref{classsisl_1_1bcc__quintic__rdo}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1body__centered__cubic}{sisl\+::body\+\_\+centered\+\_\+cubic$<$ T $>$} \\*Defines the body centered cubic lattice in 3d }{\pageref{classsisl_1_1body__centered__cubic}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1cartesian__cubic}{sisl\+::cartesian\+\_\+cubic$<$ T $>$} \\*A specialized cubic Cartesian lattice class }{\pageref{classsisl_1_1cartesian__cubic}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1cartesian__planar}{sisl\+::cartesian\+\_\+planar$<$ T $>$} \\*A specialized Cartesian planar lattice class }{\pageref{classsisl_1_1cartesian__planar}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1function}{sisl\+::function} \\*Abstract base class for a function. Defines a function that is valid over all R$^\wedge$n, it\textquotesingle{}s up to the underlying implementation to decide how those values map to real values }{\pageref{classsisl_1_1function}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1utility_1_1isosurface}{sisl\+::utility\+::isosurface} \\*An implementation of marching cubes }{\pageref{classsisl_1_1utility_1_1isosurface}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1test_1_1marschner__lobb}{sisl\+::test\+::marschner\+\_\+lobb} \\*Marschner lobb test function }{\pageref{classsisl_1_1test_1_1marschner__lobb}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1nearest__neighbor}{sisl\+::nearest\+\_\+neighbor} \\*Nearest neighbor interpolation for any lattice. Simply finds the nearest lattice site and returns the value at that site. This class doesn\textquotesingle{}t implement phi or dphi functions, as one would need to know the lattice a-\/priori for those, and this class structure isn\textquotesingle{}t sophisticated enough to facilitate that }{\pageref{classsisl_1_1nearest__neighbor}}{}
\item\contentsline{section}{\hyperlink{structsisl_1_1plane}{sisl\+::plane} \\*3D plane class }{\pageref{structsisl_1_1plane}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1utility_1_1ply__mesh}{sisl\+::utility\+::ply\+\_\+mesh} \\*A barebones ply mesh writer }{\pageref{classsisl_1_1utility_1_1ply__mesh}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1utility_1_1ppm__image}{sisl\+::utility\+::ppm\+\_\+image} \\*P\+PM image writer }{\pageref{classsisl_1_1utility_1_1ppm__image}}{}
\item\contentsline{section}{\hyperlink{structsisl_1_1ray}{sisl\+::ray} \\*A ray in space }{\pageref{structsisl_1_1ray}}{}
\item\contentsline{section}{\hyperlink{struct__fftwalloc_1_1rebind}{\+\_\+fftwalloc$<$ T $>$\+::rebind$<$ U $>$} }{\pageref{struct__fftwalloc_1_1rebind}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1si__function}{sisl\+::si\+\_\+function$<$ L, B\+F, N $>$} \\*Combines a lattice and a generating function }{\pageref{classsisl_1_1si__function}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1sparse__array__n}{sisl\+::sparse\+\_\+array\+\_\+n$<$ T, N, Allocator $>$} \\*An n-\/dimensional sparese array. This class abstracts away the concept of an n-\/dimensional array, it should be easy to create an array of type T on N dimensions. It differes from an array in that, when instantiated, it consumes no memory. When you begin to fill cells of the array with data, only then does memory begin to fill up. Accessing a cell without data returns \char`\"{}default\+Value\char`\"{}, which is set in the constructor }{\pageref{classsisl_1_1sparse__array__n}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1test_1_1test__window}{sisl\+::test\+::test\+\_\+window} \\*Windowed test function }{\pageref{classsisl_1_1test_1_1test__window}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1tp__cubic}{sisl\+::tp\+\_\+cubic} \\*Tensor product cubic spline }{\pageref{classsisl_1_1tp__cubic}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1tp__cubic__imom}{sisl\+::tp\+\_\+cubic\+\_\+imom} \\*Tensor product cubic interpolating M\+OM }{\pageref{classsisl_1_1tp__cubic__imom}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1tp__linear}{sisl\+::tp\+\_\+linear} \\*Tensor product linear basis function. Tensor product linear basis function. On the planar and cubic Cartesian lattices, we have F\+A\+S\+T\+\_\+\+B\+A\+S\+ES which correspond to bilinear and trilinear interpolation }{\pageref{classsisl_1_1tp__linear}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1tp__quadratic}{sisl\+::tp\+\_\+quadratic} \\*Tensor product quadratic spline }{\pageref{classsisl_1_1tp__quadratic}}{}
\item\contentsline{section}{\hyperlink{structsisl_1_1triangle}{sisl\+::triangle} \\*Triangle in 3D space }{\pageref{structsisl_1_1triangle}}{}
\item\contentsline{section}{\hyperlink{structsisl_1_1vertex3}{sisl\+::vertex3} \\*3D vertex }{\pageref{structsisl_1_1vertex3}}{}
\item\contentsline{section}{\hyperlink{classsisl_1_1zp3__element}{sisl\+::zp3\+\_\+element} }{\pageref{classsisl_1_1zp3__element}}{}
\end{DoxyCompactList}
